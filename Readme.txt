SpliceView
Author: Yafeng Zhu. Email: yafeng.zhu@scilifelab.se, yafeng.zhu@ki.se

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Overview
SpliceView is a tool for identifcation and visualization of splice variants based on shotgun proteomics data

SpliceView was written in Python 2.7.2. It consists of four scripts: converter.py, download.py, mapping.py and visualization.py. They are compressed into a package. The following python packages need to be installed for SpliceView to work: 
Biopython
Python Image Library (PIL)
numpy

Manual
Download SpliceView using the following command: (you might need to install git first, type the command in a ternimal: apt-get install git-core)
git clone https://github.com/yafeng/SpliceView 
Extract the SpliceView package. The package contains a text file named ENSP_ENSG_genesymbol.txt (a local database which stores Ensembl protein ID, gene ID and gene symbol) and some other necessary files for the program to run. Note: DO NOT move or rename original and output files generated by SpliceView.

Step1:prepare the input file for SpliceView
First, you need to extract some data from the output file of database searching and format them in a tab-delimited text file like this:
Accession	peptide sequence		1	2	3	4	5	6	7	8
ENSP00000342181 nSQDDYDEER      3638.974989     3573.00811      3754.7922       3734.386299     3359.112228     2412.318846     2468.562338     3162.3

*NOTE* In the column with sample tag 1-8, they are the intensity value from 8-plex iTRAQ labelling.(put the standard or control in the first place)
It is ok to have multiple IDs in the Accession column, but it has to be separated by semicomma (;) symbol. Peptides that belong to multiple genes will be removed before the mapping step.
	
Here, we will use the heavy_testfile.txt file (a tab-delimited text file described as in step1) to illustrate the workflow.

Step2:insert gene symbol- converter.py
Read and insert gene symbol for each entry. Each protein entry will be assigned a gene symbol which will be used to retrieve its known splice variants in the next step. This is done by converter.py.
Command: Python converter.py heavy_testfile.txt heavy

The first argument is the input file, the second is the prefix of output file. You will get an output file named as heavy_pepdata.txt. 

Step3: Download data from EVDB and GenBank - download.py 
The script in this step retrieves splice variants in EVDB by gene symbol and the translated sequences of these splice variants in GenBank.

Command: Python download.py heavy your_email@xxx.xx
(A valid email address is required to access the GenBank database through command line)
Output: splicingvar.txt, subexon.txt, varseq.fa, gene_notfound.txt, var_notfound.txt.

The output files splicingvar.txt and subexon.txt contain exon composition of each variant, both genomic and transcript coordinates. The gene_notfound.txt file contains gene symbol which is not found in the splicing variants database. The var_notfound.txt file contains mRNA accession id of splice variants that is not found in GenBank.

Tip: if you have multiple sample files in one project, it is better to put all the files under one directory named by the project and use different sample names for each file. Because usually there is a overlap of identified proteins among different samples, the script download.py first check if the splice variants of identified protein and the variant sequences have been downloaded so that it avoids downloading the data for same proteins multiple times. This step will take hours to download data from internet if there are thousands of genes.

Step4: calculate the mean intensity ratio and standard deviation of PSMs for all peptide
Most often a peptide is identified by multiple peptide spectra matchs. To calculate the relative intensity of each PSM, the intensity of each iTRAQ plex is normalized by the intensity of the standard or control using the following fomula:
X(normalized)=intensity of X/intensity of 1, X=1,2,3...
Then for each peptide, calculate the mean of all PSMs' relative intensity and the standard deviation
Command: Python normalize.py heavy
if PQPQ is not used to cluster peptides based on their quantitative patterns, all peptides will be assigned to cluster 0.

Step5: Map peptides to its transcriptional position - mapping.py
The script in this step uses output from previous step to map identified peptides to its transcriptional positions.
Command: Python mapping.py heavy 
Output: heavy_mappingout.txt, heavy_genestatistic.txt

The file mappingout.txt is PSM based format in which each row is one PSM. It will be used in the visualization part. The file Genestatistic.txt is gene based format in which each row is one gene. It is used to filter out genes of interest.

Create figure - visualization.py The script is used to visualize the gene of interest. Given a gene symbol, it will generate a high quality picture with all important information described in the paper.
Command: Python visualization.py heavy ARF5
Output:ARF5_pattern_heavy.png

The gene symbol should be exactly the same as the one you see in the file genestatistic.txt

