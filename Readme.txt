SpliceView
Author: Yafeng Zhu. Email: yafeng.zhu@scilifelab.se, yafeng.zhu@ki.se

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files, to deal
in the Software without restriction, including without limitation the rights
to non-commercially use, copy, modify, merge, redistribute the Software.
to do so, subject to the following conditions:
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Overview
SpliceView is a tool for identifcation and visualization of splice variants based on shotgun proteomics data

SpliceView was written in Python 2.7.2. It consists of four scripts: converter.py, download.py, mapping.py and visualization.py. They are compressed into a package. The following python packages need to be installed for SpliceView to work: 
Biopython
Python Image Library (PIL)
numpy
scipy (only needed if you run step5-pqpq2.py)

Manual
Download SpliceView using the following command: (you might need to install git first, type the command in a ternimal: apt-get install git-core)
git clone https://github.com/yafeng/SpliceView 
Extract the SpliceView package. The package contains a text file named ENSP_ENSG_genesymbol.txt (a local database which stores Ensembl protein ID, gene ID and gene symbol) and some other necessary files for the program to run. Note: DO NOT move or rename original and output files generated by SpliceView.

Step1:prepare the input file for SpliceView
First, you need to extract some data from the output file of database searching and format them in a tab-delimited text file like this:
Accession	peptide sequence		1	2	3	4	5	6	7	8
ENSP00000342181 nSQDDYDEER      3638.974989     3573.00811      3754.7922       3734.386299     3359.112228     2412.318846     2468.562338     3162.3

*NOTE* In the column with sample tag 1-8, they are the intensity value from 8-plex iTRAQ labelling.(put the standard or control in the first place). Tip: copy and paste the needed columns in EXCEL, and then copy and save it in a plain text file.
It is ok to have multiple IDs in the Accession column, but it has to be separated by semicomma (;) symbol. Peptides that belong to multiple genes will be removed before the mapping step.
	
Here, we will use the heavy_testfile.txt file (a tab-delimited text file described as in step1) to illustrate the workflow.

Step2:insert gene symbol- converter.py
Read and insert gene symbol for each entry. Each protein entry will be assigned a gene symbol which will be used to retrieve its known splice variants in the next step. This is done by converter.py.
Command: Python converter.py heavy_testfile.txt heavy

The first argument is the input file, the second is the prefix of output file. You will get an output file named as heavy_psmdata.txt. 

Step3: Download data from EVDB and GenBank - download.py 
The script in this step retrieves splice variants in EVDB by gene symbol and the translated sequences of these splice variants in GenBank.

Command: Python download.py heavy your_email@xxx.xx
(A valid email address is required to access the GenBank database through command line)
Output: splicingvar.txt, subexon.txt, varseq.fa, gene_notfound.txt, var_notfound.txt.

The output files splicingvar.txt and subexon.txt contain exon composition of each variant, both genomic and transcript coordinates. The gene_notfound.txt file contains gene symbol which is not found in the splicing variants database. The var_notfound.txt file contains mRNA accession id of splice variants that is not found in GenBank.

Tip: if you have multiple sample files in one project, it is better to put all the files under one directory named by the project and use different sample names for each file. Because usually there is a overlap of identified proteins among different samples, the script download.py first check if the splice variants of identified protein and the variant sequences have been downloaded so that it avoids downloading the data for same proteins multiple times. This step will take hours to download data from internet if there are thousands of genes.

Step4: calculate the mean intensity ratio and standard deviation of PSMs for all peptide
Most often a peptide is identified by multiple peptide spectra matchs. To calculate the relative intensity of each PSM, the intensity of each iTRAQ plex is normalized by the intensity of the standard or control using the following fomula:
X(normalized)=intensity of X/intensity of 1, X=1,2,3...
Then for each peptide, calculate the mean of all PSMs' relative intensity and the standard deviation.
Command: Python normalize.py heavy
output: heavy_pepdata.txt
if PQPQ2 is not used to cluster peptides based on their quantitative patterns, all peptides will be assigned to cluster 0.

Step5: clustering-pqpq2.py
This step will cluster peptides based on their quantitative patterns, each peptide will be assigned a number to indicate which cluster it belongs. If one protein has only one unique peptide, then this peptide will get a number '0'  instead.
Command: python pqpq2.py --i heavy_pepdata.txt --o heavy_pqpqout.txt
The --i argument should be the output from step4 (heavy_pepdata.txt), --o argument is the name of output file. There are some other options to use. 
--metric defines the way to calculate the distance, "euclidean" is the default. "correlation" can also be used.
--method defines the way of calculating the distance between the newly formed clusters. Available options is "single","complete","average","weighted". "average" is the default.
--d set the distance cutoff for generating a new cluster. Default value is 0.4. 

Step6: Map peptides to its transcriptional position - mapping.py
The script in this step maps identified peptides to its transcriptional positions. 
NOTE: if step5 is skipped, the input file of this step is the output of step4, which is heavy_pepdata.txt. If step5 is not skipped, the input file of this step is the output of step5, which is heavy_pqpqout.txt.

Command: Python mapping.py heavy_pepdata.txt heavy (if step5 is skipped)
Command: Python mapping.py heavy_pqpqout.txt heavy (if step5 is not skipped)
The first argument is input file and the second is the prefix of output file
Output: heavy_mappingout.txt, heavy_genestatistic.txt

The file mappingout.txt is peptide based format in which each row is one unique peptide. It will be used in the visualization part. The file Genestatistic.txt is gene based format in which each row is one gene. It is used to filter out genes of interest.

Step7: Create figure - visualization.py The script is used to visualize the gene of interest. Given a gene symbol, it will generate a high quality picture which contains the exon composition of known splice variants, transcriptional positions of identified peptides and quantitative patterns of peptides.

Command: Python visualization.py heavy ARF5
Output:ARF5_pattern_heavy.png

The gene symbol should be exactly the same as the one you see in the file genestatistic.txt